//----------------------------------------------------------------------------
//  Project owltst1
//  My Copmany
//  Copyright 1998. All right reserved.
//
//  SUBSYSTEM:    owltst1 Application
//  FILE:         owltst1app.cpp
//  AUTHOR:       Author
//
//  OVERVIEW
//  ~~~~~~~~
//  Source file for implementation of Towltst1Appl (TApplication).
//  (Generated by OWL 6.0 Wizard for VC.)
//----------------------------------------------------------------------------
#include "owlpch.h"

#include <stdio.h>


#include "owltst1app.h"
//#include "owltst1cl.h" // Definition of client class.

#include "owltst1ab.h"  // Definition of about dialog.

static TEventSemaphore EventDead;

TWindowsThread::TWindowsThread(Towltst1View* parent)
:
	Parent(parent)
{
	Parent->GetClientRect(Border);
}
//
void TWindowsThread::UpdateBoundary()
{
	TCriticalSection::TLock lock(Parent->GetDCLock());
	Parent->GetClientRect(Border);
}
//
void TWindowsThread::Terminate()
{
	TThread::Terminate();
	EventWait.Set();
	// allow thread to run at higher priority during kill process
	SetPriority(THREAD_PRIORITY_ABOVE_NORMAL);
}
//
bool TWindowsThread::ShouldTerminate() const
{
	return (WaitForSingleObject(EventWait, 0) != WAIT_TIMEOUT);
}

///////////////

static TColor GetRandomColor()
{
	static TColor colors[] = {
			TColor::LtGray,
			TColor::Gray,
			TColor::LtRed,
			TColor::LtGreen,
			TColor::LtYellow,
			TColor::LtBlue,
			TColor::LtMagenta,
			TColor::LtCyan,
	};

	return colors[rand()%COUNTOF(colors)];
}

//
TBallThread::TBallThread(Towltst1View* parent)
:
	TWindowsThread(parent),
	Brush(0)
{
	Brush = new TBrush(GetRandomColor());
	Position.top	= rand()%100;
	Position.left = rand()%100;
	Position.bottom	= Position.top  + rand()%60+20;
	Position.right	= Position.left + rand()%60+20;

	Velocity.cx = (rand()%10)+2;
	Velocity.cy = (rand()%10)+2;
}

TBallThread::~TBallThread()
{
	delete Brush;
}
//
int TBallThread::Run()
{
	while(!ShouldTerminate()){
		//Sleep(20);
		Position += Velocity;

		if (Position.top<Border.top) 
			Velocity.cy = (Velocity.cy>0) ? Velocity.cy : -Velocity.cy;
		if (Position.bottom>Border.bottom) 
			Velocity.cy = (Velocity.cy>0) ? -Velocity.cy : Velocity.cy;

		if (Position.left<Border.left) 
			Velocity.cx = (Velocity.cx>0) ? Velocity.cx : -Velocity.cx;

		if (Position.right>Border.right) 
			Velocity.cx = (Velocity.cx>0) ? -Velocity.cx : Velocity.cx;

		// Since all threads share the same HDC it is necessary
		// to block all other threads while we render in the HDC
		{
			TCriticalSection::TLock lock(Parent->GetDCLock());

			Parent->GetDC().SelectObject(*Brush);
			Parent->GetDC().Ellipse(Position);
			Parent->GetDC().RestoreBrush();

			// Win32 optimizes GDI calls by collecting them in a batch
			// and then thunking the whole batch at once on a per
			// thread basis.  Since we share an HDC with multiple 
			// threads, we must flush the batch before yielding to
			// other threads that will adjust the HDC.  To see what
			// I mean, comment out the GdiFlush() function call and 
			// watch the results.
			GdiFlush();
		}
	}
	EventDead.Set();
	return 0;
}
//
//
//
TRectThread::TRectThread(Towltst1View* parent)
: 
	TWindowsThread(parent),
	Brush(0)
{
	Brush = new TBrush(GetRandomColor());
	Position.top	= rand()%100;
	Position.left = rand()%100;
	Position.bottom	= Position.top  + rand()%60+20;
	Position.right	= Position.left + rand()%60+20;
	
	Velocity.cx = (rand()%10)+2;
	Velocity.cy = (rand()%10)+2;
}
TRectThread::~TRectThread()
{
	delete Brush;
}
//
int TRectThread::Run()
{
	while(!ShouldTerminate()){
		//Sleep(20);
		Position += Velocity;

		if (Position.top<Border.top) 
			Velocity.cy = (Velocity.cy>0) ? Velocity.cy : -Velocity.cy;
		if (Position.bottom>Border.bottom) 
			Velocity.cy = (Velocity.cy>0) ? -Velocity.cy : Velocity.cy;

		if (Position.left<Border.left) 
			Velocity.cx = (Velocity.cx>0) ? Velocity.cx : -Velocity.cx;

		if (Position.right>Border.right) 
			Velocity.cx = (Velocity.cx>0) ? -Velocity.cx : Velocity.cx;

		// Since all threads share the same HDC it is necessary
		// to block all other threads while we render in the HDC
		{
			TCriticalSection::TLock lock(Parent->GetDCLock());

			Parent->GetDC().SelectObject(*Brush);
			Parent->GetDC().Rectangle(Position);
			Parent->GetDC().RestoreBrush();

			// Win32 optimizes GDI calls by collecting them in a batch
			// and then thunking the whole batch at once on a per
			// thread basis.  Since we share an HDC with multiple 
			// threads, we must flush the batch before yielding to
			// other threads that will adjust the HDC.  To see what
			// I mean, comment out the GdiFlush() function call and 
			// watch the results.
			GdiFlush();
		}
	}
	EventDead.Set();
	return 0;
}
//
//
TLineThread::TLineThread(Towltst1View* parent)
: 
	TWindowsThread(parent),
	Pen(0)
{
	Position1.x	= rand()%100;
	Position1.y	= rand()%100;
	Position2.x	= Position1.x + rand()%60 + 20;
	Position2.y	= Position1.y + rand()%60 + 20;
	Velocity1.cx	= (rand()%10)+2;
	Velocity1.cy	= (rand()%10)+2;
	Velocity2.cx	= (rand()%5)+2;
	Velocity2.cy	= (rand()%5)+2;

	Pen = new TPen(GetRandomColor());
}

TLineThread::~TLineThread()
{
	delete Pen;
}
int TLineThread::Run()
{
	while(!ShouldTerminate()){
		//Sleep(20);
		Position1 += Velocity1;
		Position2 += Velocity2;

		if(Position1.y<Border.top) 
			Velocity1.cy = (Velocity1.cy>0) ? Velocity1.cy : -Velocity1.cy;
		else if (Position1.y>Border.bottom) 								   
			Velocity1.cy = (Velocity1.cy>0) ? -Velocity1.cy : Velocity1.cy;

		if (Position2.y<Border.top) 
			Velocity2.cy = (Velocity2.cy>0) ? Velocity2.cy : -Velocity2.cy;
		else if (Position2.y>Border.bottom) 								   
			Velocity2.cy = (Velocity2.cy>0) ? -Velocity2.cy : Velocity2.cy;

		if (Position1.x<Border.left) 
			Velocity1.cx = (Velocity1.cx>0) ? Velocity1.cx : -Velocity1.cx;
		else if (Position1.x>Border.right) 								   
			Velocity1.cx = (Velocity1.cx>0) ? -Velocity1.cx : Velocity1.cx;

		if (Position2.x<Border.left) 
			Velocity2.cx = (Velocity2.cx>0) ? Velocity2.cx : -Velocity2.cx;
		else if (Position2.x>Border.right) 								   
			Velocity2.cx = (Velocity2.cx>0) ? -Velocity2.cx : Velocity2.cx;

		// Since all threads share the same HDC it is necessary
		// to block all other threads while we render in the HDC
		{
			TCriticalSection::TLock lock(Parent->GetDCLock());

			Parent->GetDC().SelectObject(*Pen);
			Parent->GetDC().MoveTo(Position1);
			Parent->GetDC().LineTo(Position2);
			Parent->GetDC().RestorePen();

			// Win32 optimizes GDI calls by collecting them in a batch
			// and then thunking the whole batch at once on a per
			// thread basis.  Since we share an HDC with multiple 
			// threads, we must flush the batch before yielding to
			// other threads that will adjust the HDC.  To see what
			// I mean, comment out the GdiFlush() function call and 
			// watch the results.
			GdiFlush();
		}
	}
	EventDead.Set();
	return 0;
}
//{{Towltst1Appl Implementation}}

//
// Build a response table for all messages/commands handled
// by the application.
//
DEFINE_RESPONSE_TABLE1(Towltst1Appl, TApplication)
//{{Towltst1ApplRSP_TBL_BEGIN}}
//{{Towltst1ApplRSP_TBL_END}}
END_RESPONSE_TABLE;


//--------------------------------------------------------
// Towltst1Appl
//

Towltst1Appl::Towltst1Appl() : TApplication("owltst1")
{
  // INSERT>> Your constructor code here.
}


Towltst1Appl::~Towltst1Appl()
{
  // INSERT>> Your destructor code here.
}


//--------------------------------------------------------
// Towltst1Appl
// ~~~~~
// Application intialization.
//
void Towltst1Appl::InitMainWindow()
{
  if (nCmdShow != SW_HIDE)
    nCmdShow = (nCmdShow != SW_SHOWMINNOACTIVE) ? SW_SHOWNORMAL : nCmdShow;

  TSDIFrame* frame = new TSDIFrame(0, GetName(), new Towltst1View(0,0), NULL);


  // Assign icons for this application.
  //
  frame->SetIcon(this, IDI_SDIAPPLICATION);
  frame->SetIconSm(this, IDI_SDIAPPLICATION);

  // Menu associated with window and accelerator table associated with table.
  //
  frame->AssignMenu(IDM_SDI);

  // Associate with the accelerator table.
  //
  frame->Attr.AccelTable = IDM_SDI;

  SetMainWindow(frame);

  frame->SetMenuDescr(TMenuDescr(IDM_SDI));
}


//------------------------------------------------------------------------------
// Towltst1Appl
// ~~~~~~~~~~~
// Menu File Open command
//
//{{TSDIFrame Implementation}}


TSDIFrame::TSDIFrame(TWindow* parent, LPCTSTR title, TWindow* clientWnd, TModule* module)
:
	TFrameWindow(parent, title, clientWnd, module)
{
  // INSERT>> Your constructor code here.
}


TSDIFrame::~TSDIFrame()
{
  // INSERT>> Your destructor code here.
}
////////////
//
DEFINE_RESPONSE_TABLE1(Towltst1View, TWindow)
//{{Towltst1ViewRSP_TBL_BEGIN}}
	EV_COMMAND(CM_NEW_BALL,				CmNewBall),
	EV_COMMAND(CM_NEW_RECTANGLE,	CmNewRectangle),
	EV_COMMAND(CM_NEW_LINE,				CmNewLine),

	EV_COMMAND(CM_NEW_10BALL,			CmNew10Balls),
	EV_COMMAND(CM_NEW_10RECTANGLE,CmNew10Rectangles),
	EV_COMMAND(CM_NEW_10LINE,			CmNew10Lines),
	
	EV_COMMAND(CM_NEW_25BALL,			CmNew25Balls),
	EV_COMMAND(CM_NEW_25RECTANGLE,CmNew25Rectangles),
	EV_COMMAND(CM_NEW_25LINE,			CmNew25Lines),

	EV_WM_SIZE,
//	ON_WM_DESTROY()
//	ON_WM_CREATE()
//	ON_WM_SIZE()

	EV_COMMAND(CM_KILL_FAST, CmKillThreads),
	EV_COMMAND(CM_KILL_SLOW, CmKillThreadsSlow),
//{{Towltst1ViewRSP_TBL_END}}
END_RESPONSE_TABLE;

Towltst1View::Towltst1View(TWindow* parent, LPCTSTR title, TModule* module )
:
	TWindow(parent, title, module),
	DC(0)
{
	SetBkgndColor(NoColor);
}
//
Towltst1View::~Towltst1View()
{
	Destroy(IDCANCEL);
}
//
void Towltst1View::SetupWindow()
{
	TWindow::SetupWindow();
	SetTitles();
	DC = new TClientDC(*this);
	//DC = new TWindowDC(*this);
}
//
void Towltst1View::CleanupWindow()
{
	CmKillThreadsSlow();
	delete DC;
	TWindow::CleanupWindow();
}
//
void Towltst1View::SetTitles()
{
	_TCHAR title[80];
	if(Threads.Size())
		wsprintf(title,_T("tst - %d thread"),Threads.Size());
	else
		_tcscpy(title,_T("Tst - (no threads)"));
	GetApplication()->GetMainWindow()->SetCaption(title);
}

void Towltst1View::EvSize(uint sizeType, TSize& size)
{
	TWindow::EvSize(sizeType, size);
	for(int i = 0; i < Threads.Size();i++)
		Threads[i]->UpdateBoundary();
}

void Towltst1View::CmNewBall()
{
  TBallThread* thread = new TBallThread(this);
  thread->Start();
  thread->Suspend();
	thread->SetPriority(THREAD_PRIORITY_IDLE);
	Threads.Add(thread);
	SetTitles();
  thread->Resume();
}
void Towltst1View::CmNewRectangle()
{
  TRectThread* thread = new TRectThread(this);
  thread->Start();
  thread->Suspend();
	thread->SetPriority(THREAD_PRIORITY_IDLE);
	Threads.Add(thread);
	SetTitles();
  thread->Resume();
}
void Towltst1View::CmNewLine()
{
  TLineThread* thread = new TLineThread(this);
  thread->Start();
  thread->Suspend();
	thread->SetPriority(THREAD_PRIORITY_IDLE);
	Threads.Add(thread);
	SetTitles();
  thread->Resume();
}
void Towltst1View::CmNew10Balls()
{
	for(int i = 0; i < 10; i++)
		CmNewBall();
}
void Towltst1View::CmNew10Rectangles()
{
	for(int i = 0; i < 10; i++)
		CmNewRectangle();
}
void Towltst1View::CmNew10Lines()
{
	for(int i = 0; i < 10; i++)
		CmNewLine();
}
void Towltst1View::CmNew25Balls()
{
	for(int i = 0; i < 25; i++)
		CmNewBall();
}
void Towltst1View::CmNew25Rectangles()
{
	for(int i = 0; i < 25; i++)
		CmNewRectangle();
}
void Towltst1View::CmNew25Lines()
{
	for(int i = 0; i < 25; i++)
		CmNewLine();
}
/////////////////////////////////////////////////////////////////////////
// A preferred method for killing many threads.  Tell them to go away all
// at once, then wait for them all to be scheduled and to terminate
// themselves.  This is much, much faster than the more straight forward
// way of asking just one to terminate, then waiting for it to do so.
// It is also a little bit more complex.
void Towltst1View::CmKillThreads()
{
	for(int i = 0; i < Threads.Size();i++)
		Threads[i]->Terminate();

	while(Threads.Size()){
		TEventSemaphore::TLock(EventDead, TEventSemaphore::NoLimit);
		::Sleep(Threads.Size()*2);// 200ms for every 100 threads
		for(int i = 0; i < Threads.Size(); i++){
			if (int(Threads[i]->WaitForExit(0))<=0){
				delete Threads[i];
				Threads[i] = 0;
			}
		}
		for(int j = 0; j < Threads.Size(); ){
			if(Threads[j]==0){
				Threads.Detach(j);
				continue;
			}
			j++;
		}
		SetTitles();
	}
	Invalidate();
}
void Towltst1View::CmKillThreadsSlow()
{
	while(Threads.Size()){
		for(int i = 0; i < Threads.Size();i++){
			if (Threads[i] != 0) {
				if(int(Threads[i]->TerminateAndWait(100))<=0){
					delete Threads[i];
					Threads[i] = 0;
				}
			}
		}
		for(int j = 0; j < Threads.Size(); j++){
			if(Threads[j]==0)
				Threads.Destroy(j);
		}
		SetTitles();
	}
	Invalidate();
}
/////////
int OwlMain(int , LPTSTR [])
{
  return Towltst1Appl().Run();
}

