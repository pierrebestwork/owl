//----------------------------------------------------------------------------
//  ObjectWindows, OWL NExt
//  Copyright 1998-1999 by Yura Bidus. All Rights reserved. 
//
//$Revision: 1.25 $
//$Author: jogybl $
//$Date: 2007-07-20 10:47:43 $
//
//  OVERVIEW
//  ~~~~~~~~
//  Source file for implementation of TMemComboBox (TComboBox).
//  (Generated by OWL 6.x Class Expert for MS VC++, Version 1.5)
//----------------------------------------------------------------------------
#if  defined(__BORLANDC__)
#pragma hdrignore SECTION
#endif
#include <owl/pch.h>

#include <owl/configfl.h>
#include <owl/memcbox.h>

__OWL_BEGIN_NAMESPACE

OWL_DIAGINFO;
DIAG_DECLARE_GROUP(OwlControl);

#if !defined(SECTION) || SECTION == 1

static _TCHAR countName[] = _T("Count");
static _TCHAR valueName[] = _T("Value");

//
// Build a response table for all messages/commands handled
// by the application.
//
DEFINE_RESPONSE_TABLE1(TMemComboBox, TComboBox)
  EV_WM_KILLFOCUS,
END_RESPONSE_TABLE;


//--------------------------------------------------------
// TMemComboBox Constructor
//
TMemComboBox::TMemComboBox(TWindow* parent, int id, int x, int y, int w, int h, 
                           const owl_string& name, uint textLimit, 
                           uint itemLimit, TModule* module)
: 
  TComboBox(parent, id, x, y, w, h, CBS_DROPDOWN, textLimit, module),
  Name(name),
  ItemLimit(itemLimit)
{
}
//
TMemComboBox::TMemComboBox(TWindow* parent, int resId, const owl_string& name,
                           uint textLimit, uint itemLimit, TModule* module) 
: 
  TComboBox(parent, resId, textLimit, module),
  Name(name),
  ItemLimit(itemLimit)
{
}
//
owl_string TMemComboBox::GetSectionName()
{
  return _T("History Lists\\");
}
//
void TMemComboBox::CleanupWindow()
{
  SaveContents();

  // Call base class function.
  TComboBox::CleanupWindow();
}
//
void TMemComboBox::SetupWindow()
{  
  // Call base class function.
  TComboBox::SetupWindow();

  LoadContents();
}
//
void
TMemComboBox::LoadContents()
{
  TPointer<TConfigFile> config = CreateConfigFile();

  owl_string sec_name = GetSectionName() + Name;

  TConfigFileSection section(*(TConfigFile*)config, sec_name.c_str());

  int count = section.ReadInteger(countName);

  TTmpBuffer<_TCHAR> nameBuf(MAX_PATH);
  TTmpBuffer<_TCHAR> valBuf(MAX_PATH);
  for(int i = 0; i < count; i++)
  {
    wsprintf(nameBuf, _T("%s%d"), valueName, i);
    if (section.ReadString(nameBuf,valBuf,MAX_PATH,_T("")))
    {
      AddString(valBuf);
    }
  }

  wsprintf(nameBuf, _T("%s"), valueName);
  if (section.ReadString(nameBuf, valBuf, MAX_PATH, _T("")))
    SetWindowText(valBuf);
  else
    SetWindowText(_T(""));
}
//
void
TMemComboBox::SaveContents()
{
  TPointer<TConfigFile> config = CreateConfigFile();
  owl_string sec_name = GetSectionName() + Name;
  TConfigFileSection section(*(TConfigFile*)config, sec_name.c_str());

  TTmpBuffer<_TCHAR> nameBuf(MAX_PATH);
  GetText(nameBuf, MAX_PATH);
  if(::_tcslen(nameBuf))
     AddToList(nameBuf);

  uint count = GetCount();
  if(count > ItemLimit)
    count = ItemLimit;
  section.WriteInteger(countName, count);

  TTmpBuffer<_TCHAR> valBuf(MAX_PATH);

  wsprintf(nameBuf, _T("%s"), valueName);
  if (GetWindowText(valBuf, MAX_PATH) > 0)
    section.WriteString(nameBuf, valBuf);
  else
    section.EraseEntry(nameBuf); // If the combo box text is empty, clear the old value


  for(int i = 0; i < (int)count; i++)
  {
    wsprintf(nameBuf, _T("%s%d"), valueName, i);
    if(GetString(valBuf, i) > 0)
      section.WriteString(nameBuf, valBuf);
  }
}
//
TConfigFile*
TMemComboBox::CreateConfigFile()
{
  return new TRegConfigFile(_T("OWL Next"));
}
//
void TMemComboBox::EvKillFocus(HWND hWndGetFocus)
{  
  Inherited::EvKillFocus(hWndGetFocus);
  
  TTmpBuffer<_TCHAR> nameBuf(MAX_PATH);
  GetText(nameBuf, MAX_PATH);
  if (::_tcslen(nameBuf))
  {
    AddToList(nameBuf);
    SetSelIndex(0);    // AddToList() will clear the text box, so the need to restore it 
  }
}
//
void TMemComboBox::AddToList(LPTSTR text)
{
  int index = FindStringExact(text,-1);
  if (index != CB_ERR)
    DeleteString(index);
  InsertString(text, 0);
}
//
uint TMemComboBox::Transfer(void* buffer, TTransferDirection direction)
{  
  // No combobox transfer
  //TComboBox::Transfer(buffer,direction);
  if (direction == tdGetData)
    GetText((_TCHAR *)buffer, TextLimit);
  else if (direction == tdSetData)
    SetText((_TCHAR *)buffer);
  return TextLimit * sizeof(_TCHAR);
}
//
#endif
#if !defined(SECTION) || SECTION == 2
IMPLEMENT_STREAMABLE1(TMemComboBox, TComboBox);

#if !defined(BI_NO_OBJ_STREAMING)

//
// Reads an instance of TMemComboBox from the supplied ipstream
//
void*
TMemComboBox::Streamer::Read(ipstream& is, uint32 /*version*/) const
{
  ReadBaseObject((TComboBox*)GetObject(), is);
  is >> GetObject()->Name;
  is >> GetObject()->ItemLimit;
  return GetObject();
}

//
// Writes the TComboBox to the supplied opstream
//
void
TMemComboBox::Streamer::Write(opstream& os) const
{
  WriteBaseObject((TComboBox*)GetObject(), os);
  os << GetObject()->Name;
  os << GetObject()->ItemLimit;
}
#endif  // if !defined(BI_NO_OBJ_STREAMING)
#endif  // !defined(SECTION) || SECTION == 2

__OWL_END_NAMESPACE
